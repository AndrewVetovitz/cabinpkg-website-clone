### コマンドの仕様

#### install
`poac install hoge` で，hogeの最新がインストールされます．
もしくは，カレントディレクトリに以下の内容を記述した`poac.yml`ファイルを作成し，
`poac install`とすることでも同様のことが可能です．
```yaml
deps:
  hoge: latest
```

許容される文法は以下です．
`poac install name=version`
`poac install name`
`poac install name1=version name2`

versionは範囲で指定することも可能です．
その際，以下のように，ダブルクオートもしくはシングルクオートで括ってください．でないとエラーになります．
`poac install "name=>=1.0.0 and <2.0.0"`

versionが指定無しの場合は，自動的に最新のものが選択されます．
つまり，`poac install name=latest`と同じ意味に解釈されます．
poac.ymlに追加される際，範囲に変換されます．(--outside option (現在未実装) 参照)
`latest`以外の場合は，そのままのバージョンでpoac.ymlに書き込まれます．

nameには，`new`コマンドで示す条件が適用されます．
半角小文字アルファベットと，半角数字, `/`, `-`, `_` のみが使用できます．
正規表現で表すなら，`^([a-z|\d|\-|_|\/]*?)=(.*)$`となります．
それ以外を使用した時は即終了します．
もちろん，versionもsetting-file.mdに示した基本文法に則していない場合はエラーです．
install時のnameに対しても処理を施して事前にthrowする．
installの場合は，リクエストをハックされないようにするため．versionは指定しないのか？-> Intervalの生成時に正規表現でチェックするため大丈夫
newコマンドも．→ ディレクトリ作成に失敗するから．
publishは，Golang側で失敗させるからOK
initは，OK
記号だけの名前のパッケージ --- とか，_ はアウト
最初や最後に記号がつくのはアウト -> /も含む -> 最初は対応済み
数字だけもアウト 0985 とか．数字から始まるのも？？？
///// や，/ は対応済み
使用可能な記号のうち，`/-`, `//`, `--`, 等の，二回以上連続して使用することはできません．

publish時と，installと，newの時にこれらのチェックが行われます


同じパッケージ名で同じバージョンのものを複数書いた場合は，警告なしに実行時依存でどちらかが優先されます．
これは，全く同じであればただの重複削除ですが，sourceが違う場合にも適用され，どちらが選択されるかは未定義です．
また，処理順序の影響で，同じパッケージのバージョン解決を複数回することになるため，実行速度に影響が出る恐れがあります．
内部では，intervalからversionに変換します．
そのため，
A: >=1.0.0 and <2.0.0
A: >=1.1.0 and <2.0.0
は，intervalとしては異なりますが，versionとしては同じかもしれません．
そのため，versionを固定化してから重複削除する必要があるので，実行速度に影響が出ます．

poac install A=1.0.0
poac install A=1.1.0
は失敗します．
なぜなら，全てのdepsで再計算するからです．
A=1.0.0と，A=1.1.0を同時にインストールしようとして失敗します．
updateしたい場合は，poac update A としてください．
(失敗しないように改善する可能性はあります．
Are you sure update A? [Y/n]
のような感じで．)

poac installを実行した後，poac.lockファイルが自動で生成されます．
このファイルは，依存関係を固めたものですが，このファイルを参照しながら，ビルドも行っていきます．
そのため，
* 依存が存在し，
* その依存がカレントディレクトリに存在しない
時，ビルド初期に自動で失敗し，以下の様なエラーを表示します．
```
Does not exists dependencies in deps. Please execute `poac install`
```



#### new
禁止事項

* org/name/sub
* /name


#### update
updateするには，updateコマンドを使用します．
./depsの内容を大幅に書き換えられていたら？？？ -> cuurent_nameから，for_loopできる．その際，srcがgithubでなければ良い
依存関係から後に外れたもの．
A -> B -> C だった時に，installを行なっていて，
Bが，Cに依存しなくなり，Aの依存範囲内に入っていたら，更新される．
この際，Cは完全に無視されてしまう．
そのため，定期的に./depsをcleanした方がよい．
そうした，依存関係から外れたパッケージを削除してくれるコマンドを考え中のため，今後実装される．
もちろん，B:1.0がB:2.0になった場合には，B:1.0が削除されてからB:2.0がインストールされるため，上記のようなコマンドはこのケースには不要である．

poac.ymlから，poac.lockが再現できたとしても，そこで終了とはならない．
何故なら，lockファイルは，./depsの状態を表現している訳ではないからである．
ユーザーによってファイルが削除されたり追加されたりしている可能性を考慮する必要があるからだ．
そのため，如何なる場合においても，lockファイルは無視し，poac.ymlによって生成された依存木と，./depsを比較する．
lockは古い可能性もあるからだ．
その際，違いがあれば，replaceされ，lockファイルが更新される．

各バージョンの状態に関しては，npm outdatedに則って，
Current, Wanted, Latest
の３つの状態で表される．
Currentが，現在インストールされているバージョン
Wantedが，semverで指定した範囲の条件を満たす中での最新のバージョン
Latestが，そのパッケージでの最新のバージョン

A -> Current: 1.0.0, Wanted: 0.5.0, Latest: 1.0.0
という状態で，poac update Aを実行した時，Aは，0.5.0にdowngradeされる．
つまり，updateは，更新であり，upgradeとdowngradeの両方を行うことができる．

また，A, B, Cに依存していたとき，
./depsに，AとBしか入っておらず，poac updateを実行したなら，Cがインストールされます．
これは，Cがdepsに存在しないことと，Cが存在していて新しいバージョンが存在することが同じ解釈になるためです．

##### 個別のupdate (現在未実装)

##### 依存の依存 (現在未実装)
依存の依存に対して，update指定は可能か？？？
可能です．
その場合は，依存の依存とそれ以降の依存のみが変更の対象になり，それ以外は評価されません．
例えば，
poac.ymlに
A: 1.0.0
として，
A -> B -> C
となっており，
`poac update B`とすると，BとCが評価されます．

##### --outside option (現在未実装)
--outsideを指定すると，poac.ymlに指定した範囲外に検証範囲を広げてくれます．
つまり，Wantedではなく，Latestのバージョンにupdateされるということです．
実行時に変更があれば，poac.lockだけでなく，poac.ymlも書き換えられます．
(--outsideが付いてない場合で更新が存在する場合は，poac.lockが書き換えられます)
一つのバージョンではなく，マイナーの範囲を許す範囲に設定されます．(npmでいう^(caret)に近い動作)
poac.ymlに，
A: ">1.0.0 and <=2.0.0"
A -> Current: 2.0.0, Wanted: 2.0.0, Latest: 3.0.0
だとすると，
`poac update A --outside`
で，poac.ymlは，
A: ">=3.0.0 and <4.0.0"
に書き換えられます．
先ほど，npmでいう^(caret)に **近い** 動作と表現したのは，
`>=0.0.1 and <0.0.2` とnpmだとなるのに対し，
--outside optionだと，
`>=0.0.1 and <1.0.0` となるからです．
(poacは，一番左のmajorバージョンしか見ない．つまり，majorバージョンのみの固定化を行う)

##### 指定のバージョンにupdateしたい
poac.ymlの範囲を調節してください．


#### graph
使い方自体は，poac --help graph等で，
詳細に，一行にとどまらず説明すべきだろう．以下のような使い方例を．

標準出力にdot形式でoutput
poac graph > hoge.dot
--output, -o でファイルを直接作成
poac graph -o hoge.dot でdot形式で出力
poac graph -o hoge.png でpng形式で出力
--input, -iで，入力する，poac.ymlファイルを指定. 指定しない場合はカレントディレクトリのを選択
poac graph -i ./deps/boost/poac.yml -o hoge.png
それ以外の拡張子を指定するとエラー
pngを指定時にgraphvisがインストールされていない（コマンドラインが使用できない）時はエラー
dot -Tpng test.dot -o test.png

つまり，以上のようなものは，仕様として説明すべきでなく，コマンド内で説明すべきであるということだ．
(良い例が，`cargo help run`によって得られる．これを参考に使用)
`cargo --help run`では，runのヘルプではなく，cargoのヘルプが表示された．これは，--helpは，cargoのオプションであって，runのオプションではないからだろう．
これと同一の動作を，poacでも実現すべきだ．

lockファイルが存在すれば，lockファイルからactivatedに変換するための関数を呼び出し，activated_to_graphを呼ぶ
存在しなければ，resolver内の関数を呼び出して，それのResolved.activatedをactivated_to_graphに渡し，graphの生成と，ついでにlockファイルも作成しておく


#### cache
これは，uninstallと違い，依存関係を解決していじってくれるものではない．
cleanで，削除したければ，個別に選択するか，全部を削除する必要がある．

#### uninstall
updateでは，依存の依存を指定することができたが，uninstallではそうはいかない．
poac.ymlに書いたものしかダメ
poac.ymlとpoac.lockの両方が書き換えられるが，poac.ymlを書き換え，それのtimestampを使用して，poac.lockに書き込む

全ての依存関係が消えた時，poac.lockファイルが完全に削除されます．
また，poac.ymlからdepsキーが消えます．

現状，poac.ymlにコメントを書いていた場合，消えてしまいます．これは，他のpoac.ymlを書き換える処理が存在するコマンド全てに共通することで，
解決策を模索中です．
uninstallは，poac.ymlとpoac.lockの依存関係と見比べながら，他に依存されていないことを確認して削除してくれるコマンドですが，
先に，poac.ymlからそのパッケージを消してしまうと，依存関係が確認できないので，消すことはできません．
その時に活用するのが，cleanupコマンドです．

全ての依存をuninstallできる

#### cleanup
cleanupでは，poac.ymlから消しているのに，./depsに取り残されてしまっているパッケージを削除してくれます．
installコマンドのバックグラウンドで自動で実行されていますが，手動で実行することも可能です．
動作としては不要なものを消してくれる機能です．


#### build
現状のビルド順序は，未定義の状態です．
つまり，どれかのパッケージがどれかのパッケージがビルドに必要な場合，失敗する恐れがあります．
依存が循環しているときの対策を考える必要があるためです．
installコマンドの流用でいけるはずですが．

現状の案としては，lockファイルをreadすることですが，lockファイルは./depsの状態をlockしているわけではないので，難しいです．
つまり，poac.ymlの状態がlockファイルの状態を再現でき，lockファイルの状態が./depsの状態を完全に再現できるときに，初めて，lockファイルを使用してbuild順序を決定できます．
これは，実行速度としては考えもの(installコマンドの大半の処理と同じ処理を行なってしまう時がある(lockファイルが存在しない時等))なので，現状実装していません．

lockファイルが存在しなければ，installを行なっていないか，消したことになります．なので，installの実行を強制します．
また，lockファイルに書かれたtimestampが，poac.ymlと一致しないということは，現在の./depsとlockファイルの状態が一致していてるが，poac.ymlは一致していません．
（ユーザーが勝手に消したら違いますが）
そうしたことを利用することで，うまく作ることができます．

現状，poacでのビルドしか受け付けていません． // !!!!!! これ重要 !!!!!!!!!!!!!!!
今後，systemに，cmakeの指定等が追加されます．
そのため，installしてきたdepsをビルドしたい時は，そのディレクトリへ移動して，cmakeなりを打つことになります．
なるべく早く実装します．
